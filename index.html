<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Trumpo Arena Battle</title>
  <!-- âœ… Pixel Font -->
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
  <style>
    body {
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      margin: 0;
      font-family: 'Press Start 2P', cursive;
      color: white;
      background: url("bg.png") no-repeat center center fixed; 
      background-size: cover;
    }

    #home, #gameContainer, #mapSelect {
      text-align: center;
    }

    h1 {
      font-size: 28px;
      color: yellow;
      text-shadow: 2px 2px 0 black;
      margin-bottom: 20px;
    }

    button {
      padding: 12px 24px;
      font-size: 14px;
      border: none;
      background: #ff4444;
      color: white;
      border-radius: 5px;
      cursor: pointer;
      margin: 10px;
      font-family: 'Press Start 2P', cursive;
    }
    button:hover { background: #ff6666; }

    #arena { border-radius: 50%; background: transparent; }

    #result {
      position: absolute;
      top: 20px;
      font-size: 16px;
      text-align: center;
      width: 100%;
      color: yellow;
      font-weight: bold;
      display: none;
      text-shadow: 2px 2px 0 black;
    }

    #restart, #menuBtn {
      position: absolute;
      left: 50%;
      transform: translate(-50%, -50%);
      padding: 10px 20px;
      font-size: 12px;
      border: none;
      background: #ff4444;
      color: white;
      border-radius: 5px;
      cursor: pointer;
      display: none;
      font-family: 'Press Start 2P', cursive;
    }

    #restart:hover, #menuBtn:hover { background: #ff6666; }
    #restart { top: 10%; }
    #menuBtn { top: 18%; }

    /* âœ… Modal Overlay */
    #instructionModal {
      display: none;
      position: fixed;
      z-index: 999;
      left: 0; top: 0;
      width: 100%; height: 100%;
      background: rgba(0, 0, 0, 0.8);
      justify-content: center;
      align-items: center;
    }

    .modal-content {
      background: #222;
      border: 4px solid #fff;
      box-shadow: 0 0 10px #ff4444, 0 0 20px #ff4444 inset;
      padding: 20px;
      text-align: left;
      max-width: 500px;
      width: 90%;
      font-size: 12px;
      line-height: 1.6;
      color: #ffeb3b;
    }

    .modal-content h2 {
      font-size: 14px;
      margin-bottom: 15px;
      text-align: center;
      color: #ff4444;
      text-shadow: 2px 2px 0 black;
    }

    .closeBtn {
      display: block;
      margin: 20px auto 0;
      padding: 8px 16px;
      background: #ff4444;
      border: none;
      color: white;
      cursor: pointer;
      font-size: 12px;
      font-family: 'Press Start 2P', cursive;
    }
    .closeBtn:hover { background: #ff6666; }

    /* âœ… Countdown Overlay */
    #countdown {
      position: absolute;
      top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      font-size: 64px;
      font-family: 'Press Start 2P', cursive;
      color: yellow;
      text-shadow: 4px 4px 0 black;
      display: none;
      z-index: 1000;
      animation: pop 1s ease-in-out;
    }

    @keyframes pop {
      0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
      50% { transform: translate(-50%, -50%) scale(1.2); opacity: 1; }
      100% { transform: translate(-50%, -50%) scale(1); opacity: 0; }
    }

    /* âœ… Skill HUD */
    #skillDisplay {
      position: absolute;
      bottom: 10px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      justify-content: space-between;
      width: 500px;
      font-size: 10px;
    }
    .playerSkills { display: flex; flex-direction: column; gap: 6px; }
    .skill {
      width: 100px; height: 14px;
      border: 2px solid white;
      position: relative;
      background: rgba(0,0,0,0.5);
    }
    .skill span {
      position: absolute; left: 50%; top: 50%;
      transform: translate(-50%, -50%);
      font-size: 8px; color: white;
    }
    .cooldown {
      position: absolute; left: 0; top: 0;
      height: 100%; background: rgba(255,0,0,0.6);
      width: 0%; transition: width 0.2s linear;
    }

    /* âœ… Map Selection */
    #mapSelect {
      display: none;
      flex-direction: column;
      align-items: center;
    }
    #mapCards {
      display: flex;
      justify-content: center;
      gap: 20px;
    }
    .mapCard {
      background: #222;
      border: 4px solid white;
      box-shadow: 0 0 10px yellow;
      cursor: pointer;
      transition: transform 0.2s, box-shadow 0.2s;
    }
    .mapCard:hover {
      transform: scale(1.05);
      box-shadow: 0 0 20px red;
    }
    .mapCard img {
      width: 250px;
      height: 300px;
      display: block;
    }
    .mapCard span {
      display: block;
      padding: 10px;
      font-size: 10px;
      color: yellow;
      text-shadow: 1px 1px 0 black;
    }
  </style>
</head>
<body>
  <!-- âœ… Home Page -->
  <div id="home">
    <h1>TRUMPO ARENA BATTLE</h1>
    <button id="startBtn">START GAME</button>
    <button id="instructionBtn">INSTRUCTIONS</button>
  </div>

  <!-- âœ… Map Selection -->
  <div id="mapSelect">
    <h1>Select a Map</h1>
    <div id="mapCards">
      <div class="mapCard" data-map="map1.png">
        <img src="map1.png" alt="Map 1"><span>Map 1</span>
      </div>
      <div class="mapCard" data-map="map2.png">
        <img src="map2.png" alt="Map 2"><span>Map 2</span>
      </div>
      <div class="mapCard" data-map="map3.png">
        <img src="map3.png" alt="Map 3"><span>Map 3</span>
      </div>
    </div>
  </div>

  <!-- âœ… Game Container -->
  <div id="gameContainer" style="display:none; position:relative;">
    <canvas id="arena" width="600" height="600"></canvas>
    <div id="result"></div>
    <button id="restart">Restart</button>
    <button id="menuBtn">Go to Menu</button>
    <div id="countdown"></div>

    <!-- âœ… Skill Display HUD -->
    <div id="skillDisplay">
      <div class="playerSkills" id="redSkills">
        <div class="skill"><div class="cooldown" id="redDashCD"></div><span>Dash</span></div>
        <div class="skill"><div class="cooldown" id="redShieldCD"></div><span>Shield</span></div>
        <div class="skill"><div class="cooldown" id="redUltCD"></div><span>Ultimate</span></div>
      </div>
      <div class="playerSkills" id="blueSkills">
        <div class="skill"><div class="cooldown" id="blueDashCD"></div><span>Dash</span></div>
        <div class="skill"><div class="cooldown" id="blueShieldCD"></div><span>Shield</span></div>
        <div class="skill"><div class="cooldown" id="blueUltCD"></div><span>Ultimate</span></div>
      </div>
    </div>
  </div>

  <!-- âœ… Modal -->
  <div id="instructionModal">
    <div class="modal-content">
      <h2>ğŸ® INSTRUCTIONS</h2>
      <p>- <span style="color:red;">Red Player</span>: Move = WASD<br>
         Dash = Space, Shield = C, Ultimate = V</p>
      <p>- <span style="color:cyan;">Blue Player</span>: Move = Arrow Keys<br>
         Dash = ., Shield = /, Ultimate = shift</p>
      <p>âš”ï¸ Knock your opponentâ€™s health to 0 to win!</p>
      <button class="closeBtn">CLOSE</button>
    </div>
  </div>

  <script>
Â  Â  const home = document.getElementById("home");
Â  Â  const mapSelect = document.getElementById("mapSelect");
Â  Â  const gameContainer = document.getElementById("gameContainer");
Â  Â  const startBtn = document.getElementById("startBtn");
Â  Â  const instructionBtn = document.getElementById("instructionBtn");
Â  Â  const instructionModal = document.getElementById("instructionModal");
Â  Â  const closeBtn = document.querySelector(".closeBtn");
Â  Â  const countdownEl = document.getElementById("countdown");
Â  Â  const menuBtn = document.getElementById("menuBtn");

Â  Â  let selectedMap = "bg.png";
Â  Â  let animationId = null; // âœ… Store the animation frame ID
Â  Â  let gameActive = false; // âœ… Flag to control movement/physics

Â  Â  startBtn.addEventListener("click", () => {
Â  Â  Â  home.style.display = "none";
Â  Â  Â  mapSelect.style.display = "flex";
Â  Â  });

Â  Â  document.querySelectorAll(".mapCard").forEach(card => {
Â  Â  Â  card.addEventListener("click", () => {
Â  Â  Â  Â  selectedMap = card.dataset.map;
Â  Â  Â  Â  document.body.style.background = `url(${selectedMap}) no-repeat center center fixed`;
Â  Â  Â  Â  document.body.style.backgroundSize = "cover";
Â  Â  Â  Â  mapSelect.style.display = "none";
Â  Â  Â  Â  gameContainer.style.display = "block";
Â  Â  Â  Â  startGame();
Â  Â  Â  });
Â  Â  });

Â  Â  instructionBtn.addEventListener("click", () => instructionModal.style.display = "flex");
Â  Â  closeBtn.addEventListener("click", () => instructionModal.style.display = "none");

Â  Â  menuBtn.addEventListener("click", () => {
Â  Â  Â  // Stop the current game loop before going to the menu
Â  Â  Â  if (animationId) cancelAnimationFrame(animationId);

Â  Â  Â  gameContainer.style.display = "none";
Â  Â  Â  home.style.display = "block";
Â  Â  Â  document.getElementById("result").style.display = "none";
Â  Â  Â  document.getElementById("restart").style.display = "none";
Â  Â  Â  menuBtn.style.display = "none";
Â  Â  Â  document.body.style.background = `url('bg.png') no-repeat center center fixed`;
Â  Â  Â  document.body.style.backgroundSize = "cover";
Â  Â  });


Â  Â  function startGame() {
Â  Â  Â  // âœ… 1. Always stop any existing game loop before starting a new one!
Â  Â  Â  if (animationId) {
Â  Â  Â  Â  cancelAnimationFrame(animationId);
Â  Â  Â  Â  animationId = null;
Â  Â  Â  }

Â  Â  Â  const canvas = document.getElementById('arena');
Â  Â  Â  const ctx = canvas.getContext('2d');
Â  Â  Â  const result = document.getElementById('result');
Â  Â  Â  const restartBtn = document.getElementById('restart');

Â  Â  Â  const arenaCenter = { x: canvas.width / 2, y: canvas.height / 2 };
Â  Â  Â  const arenaRadius = canvas.width / 2 - 10;

Â  Â  Â  // âœ… Spinning Images
Â  Â  Â  const redImg = new Image(); redImg.src = "red.png";
Â  Â  Â  const blueImg = new Image(); blueImg.src = "blue.png";

Â  Â  Â  // âœ… Defeated Images
Â  Â  Â  const defRedImg = new Image(); defRedImg.src = "def-red.png";
Â  Â  Â  const defBlueImg = new Image(); defBlueImg.src = "def-blue.png";

Â  Â  Â  // Load skill effect images
Â  Â  Â  const shieldImg = new Image(); shieldImg.src = "shield.png";
Â  Â  Â  // UPDATED: Load separate ultimate images
Â  Â  Â  const redUltImg = new Image(); redUltImg.src = "red-ult.png";
Â  Â  Â  const blueUltImg = new Image(); blueUltImg.src = "blue-ult.png";
Â  Â  Â  const dashImg = new Image(); dashImg.src = "dash.png";

Â  Â  Â  let sparks = [];
Â  Â  Â  function createSparks(x, y, color) {
Â  Â  Â  Â  for (let i = 0; i < 50; i++) {
Â  Â  Â  Â  Â  sparks.push({
Â  Â  Â  Â  Â  Â  x, y,
Â  Â  Â  Â  Â  Â  dx: (Math.random() - 0.5) * 10,
Â  Â  Â  Â  Â  Â  dy: (Math.random() - 0.5) * 10,
Â  Â  Â  Â  Â  Â  life: 20,
Â  Â  Â  Â  Â  Â  color
Â  Â  Â  Â  Â  });
Â  Â  Â  Â  }
Â  Â  Â  }
Â  Â  Â  function drawSparks(ctx) {
Â  Â  Â  Â  sparks.forEach((s, i) => {
Â  Â  Â  Â  Â  ctx.fillStyle = s.color;
Â  Â  Â  Â  Â  ctx.globalAlpha = s.life / 20;
Â  Â  Â  Â  Â  ctx.fillRect(s.x, s.y, 3, 3);
Â  Â  Â  Â  Â  ctx.globalAlpha = 1.0;
Â  Â  Â  Â  Â  s.x += s.dx;
Â  Â  Â  Â  Â  s.y += s.dy;
Â  Â  Â  Â  Â  s.life--;
Â  Â  Â  Â  Â  if (s.life <= 0) sparks.splice(i, 1);
Â  Â  Â  Â  });
Â  Â  Â  }

Â  Â  Â  class Beyblade {
Â  Â  Â  Â  constructor(x, y, color, spinImg, defImg, controls, dashKey, shieldKey, ultimateKey, prefix, ultImg) {
Â  Â  Â  Â  Â  this.x = x; this.y = y; this.color = color;
Â  Â  Â  Â  Â  Â  this.spinImg = spinImg;
Â  Â  Â  Â  Â  Â  this.defImg = defImg;
Â  Â  Â  Â  Â  this.radius = 50; this.health = 100; this.speed = 3;
Â  Â  Â  Â  Â  this.controls = controls; this.dashKey = dashKey;
Â  Â  Â  Â  Â  this.shieldKey = shieldKey; this.ultimateKey = ultimateKey;
Â  Â  Â  Â  Â  this.dx = 0; this.dy = 0;
Â  Â  Â  Â  Â  this.dashActive = false; this.shieldActive = false; this.ultimateActive = false;
Â  Â  Â  Â  Â  this.dashCooldown = false; this.shieldCooldown = false;
Â  Â  Â  Â  Â  this.ultimateCharge = 0;
Â  Â  Â  Â  Â  this.trail = [];
Â  Â  Â  Â  Â  this.prefix = prefix;
Â  Â  Â  Â  Â  // UPDATED: Store the unique ultimate image
Â  Â  Â  Â  Â  this.ultImg = ultImg;

Â  Â  Â  Â  Â  // Animation properties
Â  Â  Â  Â  Â  this.frame = 0;
Â  Â  Â  Â  Â  this.frameWidth = 110;
Â  Â  Â  Â  Â  this.frameHeight = 110;
Â  Â  Â  Â  Â  this.frameCount = 4; // Only 4 spinning frames (0, 1, 2, 3)
Â  Â  Â  Â  Â  this.isDefeated = false;
Â  Â  Â  Â  }

Â  Â  Â  Â  move(keys) {
Â  Â  Â  Â  Â  // âœ… 2. Only allow movement if the game is globally active (after countdown)
Â  Â  Â  Â  Â  if (this.isDefeated || !gameActive) return;
Â  Â  Â  Â  Â  this.dy = keys[this.controls.up] ? -this.speed : keys[this.controls.down] ? this.speed : 0;
Â  Â  Â  Â  Â  this.dx = keys[this.controls.left] ? -this.speed : keys[this.controls.right] ? this.speed : 0;
Â  Â  Â  Â  Â  this.x += this.dx; this.y += this.dy;
Â  Â  Â  Â  Â  const dx = this.x - arenaCenter.x, dy = this.y - arenaCenter.y;
Â  Â  Â  Â  Â  const dist = Math.sqrt(dx * dx + dy * dy);
Â  Â  Â  Â  Â  if (dist + this.radius > arenaRadius) {
Â  Â  Â  Â  Â  Â  const angle = Math.atan2(dy, dx);
Â  Â  Â  Â  Â  Â  this.x = arenaCenter.x + Math.cos(angle) * (arenaRadius - this.radius);
Â  Â  Â  Â  Â  Â  this.y = arenaCenter.y + Math.sin(angle) * (arenaRadius - this.radius);
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  if (keys[this.dashKey] && !this.dashActive && !this.dashCooldown) this.activateDash();
Â  Â  Â  Â  Â  if (keys[this.shieldKey] && !this.shieldActive && !this.shieldCooldown) this.activateShield();
Â  Â  Â  Â  Â  if (keys[this.ultimateKey] && this.ultimateCharge >= 100 && !this.ultimateActive) this.activateUltimate();
Â  Â  Â  Â  }

Â  Â  Â  Â  activateDash() {
Â  Â  Â  Â  Â  this.dashActive = true; this.dashCooldown = true;
Â  Â  Â  Â  Â  const angle = Math.atan2(this.dy, this.dx) || Math.random() * Math.PI * 2;
Â  Â  Â  Â  Â  this.x += Math.cos(angle) * 80; this.y += Math.sin(angle) * 80;
Â  Â  Â  Â  Â  this.trail.push({x: this.x, y: this.y, life: 15});
Â  Â  Â  Â  Â  setTimeout(() => this.dashActive = false, 300);
Â  Â  Â  Â  Â  setTimeout(() => this.dashCooldown = false, 4000);
Â  Â  Â  Â  }

Â  Â  Â  Â  activateShield() {
Â  Â  Â  Â  Â  this.shieldActive = true; this.shieldCooldown = true;
Â  Â  Â  Â  Â  setTimeout(() => this.shieldActive = false, 2000);
Â  Â  Â  Â  Â  setTimeout(() => this.shieldCooldown = false, 6000);
Â  Â  Â  Â  }

Â  Â  Â  Â  activateUltimate() {
Â  Â  Â  Â  Â  this.ultimateActive = true; this.ultimateCharge = 0;
Â  Â  Â  Â  Â  setTimeout(() => this.ultimateActive = false, 3000);
Â  Â  Â  Â  }

Â  Â  Â  Â  draw() {
Â  Â  Â  Â  Â  // Only draw dash trail if not defeated
Â  Â  Â  Â  Â  if (!this.isDefeated) {
Â  Â  Â  Â  Â  Â  this.trail.forEach((t, i) => {
Â  Â  Â  Â  Â  Â  Â  ctx.globalAlpha = t.life / 15;
Â  Â  Â  Â  Â  Â  Â  ctx.drawImage(dashImg, t.x - 30, t.y - 30, 60, 60);
Â  Â  Â  Â  Â  Â  Â  ctx.globalAlpha = 1.0;
Â  Â  Â  Â  Â  Â  Â  t.life--;
Â  Â  Â  Â  Â  Â  Â  if (t.life <= 0) this.trail.splice(i, 1);
Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  // ğŸ”¹ Beyblade drawing
Â  Â  Â  Â  Â  if (this.isDefeated) {
Â  Â  Â  Â  Â  Â  // Draw the separate static defeated image
Â  Â  Â  Â  Â  Â  ctx.drawImage(
Â  Â  Â  Â  Â  Â  Â  this.defImg,
Â  Â  Â  Â  Â  Â  Â  this.x - this.radius,
Â  Â  Â  Â  Â  Â  Â  this.y - this.radius,
Â  Â  Â  Â  Â  Â  Â  this.radius * 2,
Â  Â  Â  Â  Â  Â  Â  this.radius * 2
Â  Â  Â  Â  Â  Â  );
Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  // Draw the spinning sprite from the sheet
Â  Â  Â  Â  Â  Â  ctx.drawImage(
Â  Â  Â  Â  Â  Â  Â  this.spinImg,
Â  Â  Â  Â  Â  Â  Â  this.frame * this.frameWidth,
Â  Â  Â  Â  Â  Â  Â  0,
Â  Â  Â  Â  Â  Â  Â  this.frameWidth,
Â  Â  Â  Â  Â  Â  Â  this.frameHeight,
Â  Â  Â  Â  Â  Â  Â  this.x - this.radius,
Â  Â  Â  Â  Â  Â  Â  this.y - this.radius,
Â  Â  Â  Â  Â  Â  Â  this.radius * 2,
Â  Â  Â  Â  Â  Â  Â  this.radius * 2
Â  Â  Â  Â  Â  Â  );
Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  // ğŸ”¹ Shield (CENTERED)
Â  Â  Â  Â  Â  if (this.shieldActive && !this.isDefeated) {
Â  Â  Â  Â  Â  Â  ctx.save();
Â  Â  Â  Â  Â  Â  ctx.globalAlpha = 0.7;
Â  Â  Â  Â  Â  Â  const shieldSize = this.radius * 2.5; // Use this to calculate top-left corner
Â  Â  Â  Â  Â  Â  ctx.drawImage(shieldImg, this.x - shieldSize / 2, this.y - shieldSize / 2, shieldSize, shieldSize); // CENTERED
Â  Â  Â  Â  Â  Â  ctx.restore();
Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  // ğŸ”¹ Ultimate (Effect)
Â  Â  Â  Â  Â  if (this.ultimateActive && !this.isDefeated) {
Â  Â  Â  Â  Â  Â  ctx.save();
Â  Â  Â  Â  Â  Â  ctx.translate(this.x, this.y);
Â  Â  Â  Â  Â  Â  ctx.globalAlpha = 0.8;
Â  Â  Â  Â  Â  Â  const ultSize = this.radius * 4;
Â  Â  Â  Â  Â  Â  // UPDATED: Draw unique ultimate image
Â  Â  Â  Â  Â  Â  ctx.drawImage(this.ultImg, -ultSize / 2, -ultSize / 2, ultSize, ultSize);
Â  Â  Â  Â  Â  Â  ctx.restore();
Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  // ğŸ”¹ Health + charge bars
Â  Â  Â  Â  Â  ctx.fillStyle = "red"; ctx.fillRect(this.x - 25, this.y - 40, 50, 5);
Â  Â  Â  Â  Â  ctx.fillStyle = "lime"; ctx.fillRect(this.x - 25, this.y - 40, (this.health / 100) * 50, 5);

Â  Â  Â  Â  Â  // Only draw ultimate charge if not defeated
Â  Â  Â  Â  Â  if (!this.isDefeated) {
Â  Â  Â  Â  Â  Â  ctx.fillStyle = "gray"; ctx.fillRect(this.x - 25, this.y + 35, 50, 5);
Â  Â  Â  Â  Â  Â  ctx.fillStyle = "gold"; ctx.fillRect(this.x - 25, this.y + 35, (this.ultimateCharge / 100) * 50, 5);
Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  // Update HUD bars
Â  Â  Â  Â  Â  document.getElementById(this.prefix+"DashCD").style.width = this.dashCooldown && !this.isDefeated ? "100%" : "0%";
Â  Â  Â  Â  Â  document.getElementById(this.prefix+"ShieldCD").style.width = this.shieldCooldown && !this.isDefeated ? "100%" : "0%";
Â  Â  Â  Â  Â  document.getElementById(this.prefix+"UltCD").style.width = this.ultimateCharge < 100 && !this.isDefeated ? "100%" : "0%";
Â  Â  Â  Â  }
Â  Â  Â  }

Â  Â  Â  // UPDATED: Pass the correct ultimate image to each Beyblade
Â  Â  Â  const bey1 = new Beyblade(250, 300, "red", redImg, defRedImg,
Â  Â  Â  Â  { up: "w", down: "s", left: "a", right: "d" }, "x", "c", "v", "red", redUltImg);
Â  Â  Â  const bey2 = new Beyblade(350, 300, "blue", blueImg, defBlueImg,
Â  Â  Â  Â  { up: "arrowup", down: "arrowdown", left: "arrowleft", right: "arrowright" }, ".", "/", "shift", "blue", blueUltImg);

Â  Â  Â  let keys = {};
Â  Â  Â  document.addEventListener("keydown", e => keys[e.key.toLowerCase()] = true);
Â  Â  Â  document.addEventListener("keyup", e => keys[e.key.toLowerCase()] = false);

Â  Â  Â  function detectCollision(b1, b2) {
Â  Â  Â  Â  if (b1.isDefeated || b2.isDefeated || !gameActive) return; // âœ… Locked by gameActive
Â  Â  Â  Â  const dx = b1.x - b2.x, dy = b1.y - b2.y;
Â  Â  Â  Â  const dist = Math.sqrt(dx * dx + dy * dy);

Â  Â  Â  Â  // Core Collision Detection
Â  Â  Â  Â  if (dist < b1.radius + b2.radius) {
Â  Â  Â  Â  Â  if (!b1.shieldActive) b1.health -= b2.dashActive ? 2 : 0.5;
Â  Â  Â  Â  Â  if (!b2.shieldActive) b2.health -= b1.dashActive ? 2 : 0.5;
Â  Â  Â  Â  Â  b1.ultimateCharge = Math.min(100, b1.ultimateCharge + 2);
Â  Â  Â  Â  Â  b2.ultimateCharge = Math.min(100, b2.ultimateCharge + 2);
Â  Â  Â  Â  Â  const angle = Math.atan2(dy, dx), push = 2;
Â  Â  Â  Â  Â  b1.x += Math.cos(angle) * push; b1.y += Math.sin(angle) * push;
Â  Â  Â  Â  Â  b2.x -= Math.cos(angle) * push; b2.y -= Math.sin(angle) * push;
Â  Â  Â  Â  Â  createSparks((b1.x + b2.x) / 2, (b1.y + b2.y) / 2, "yellow");
Â  Â  Â  Â  }

Â  Â  Â  Â  // ğŸ’¥ ULTIMATE EFFECT LOGIC ğŸ’¥
Â  Â  Â  Â  const tornadoRange = 150; // Range of the ultimate effect

Â  Â  Â  Â  // Player 1 Ultimate on Player 2
Â  Â  Â  Â  if (b1.ultimateActive && dist < tornadoRange) {
Â  Â  Â  Â  Â  if (!b2.shieldActive) b2.health -= 0.5; // Damage Over Time
Â  Â  Â  Â  Â  // Pull Player 2 towards Player 1
Â  Â  Â  Â  Â  const angle = Math.atan2(b2.y - b1.y, b2.x - b1.x);
Â  Â  Â  Â  Â  b2.x -= Math.cos(angle) * 2;
Â  Â  Â  Â  Â  b2.y -= Math.sin(angle) * 2;
Â  Â  Â  Â  }

Â  Â  Â  Â  // Player 2 Ultimate on Player 1
Â  Â  Â  Â  if (b2.ultimateActive && dist < tornadoRange) {
Â  Â  Â  Â  Â  if (!b1.shieldActive) b1.health -= 0.5; // Damage Over Time
Â  Â  Â  Â  Â  // Pull Player 1 towards Player 2
Â  Â  Â  Â  Â  const angle = Math.atan2(b1.y - b2.y, b1.x - b2.x);
Â  Â  Â  Â  Â  b1.x -= Math.cos(angle) * 2;
Â  Â  Â  Â  Â  b1.y -= Math.sin(angle) * 2;
Â  Â  Â  Â  }
Â  Â  Â  }

Â  Â  Â  let gameOver = false;
Â  Â  Â  let animationCounter = 0;

Â  Â  Â  function gameLoop() {
Â  Â  Â  Â  ctx.clearRect(0, 0, canvas.width, canvas.height);
Â  Â  Â  Â  drawSparks(ctx);

Â  Â  Â  Â  if (gameActive && !gameOver) { // âœ… Only run physics/movement if active
Â  Â  Â  Â  Â  bey1.move(keys); bey2.move(keys); detectCollision(bey1, bey2);
Â  Â  Â  Â  }

Â  Â  Â  Â  bey1.draw(); bey2.draw();

Â  Â  Â  Â  // Animation update logic: Only spin the non-defeated players and if game is active
Â  Â  Â  Â  animationCounter++;
Â  Â  Â  Â  if (animationCounter % 5 === 0) {
Â  Â  Â  Â  Â  if (!bey1.isDefeated) bey1.frame = (bey1.frame + 1) % bey1.frameCount;
Â  Â  Â  Â  Â  if (!bey2.isDefeated) bey2.frame = (bey2.frame + 1) % bey2.frameCount;
Â  Â  Â  Â  Â  animationCounter = 0;
Â  Â  Â  Â  }

Â  Â  Â  Â  if (!gameOver && (bey1.health <= 0 || bey2.health <= 0)) {
Â  Â  Â  Â  Â  gameOver = true;
Â  Â  Â  Â  Â  gameActive = false; // âœ… Stop movement when game is over

Â  Â  Â  Â  Â  if (bey1.health <= 0) {
Â  Â  Â  Â  Â  Â  bey1.isDefeated = true;
Â  Â  Â  Â  Â  Â  result.innerText = "ğŸ’§ Blue Player Wins!";
Â  Â  Â  Â  Â  } else { // bey2.health <= 0
Â  Â  Â  Â  Â  Â  bey2.isDefeated = true;
Â  Â  Â  Â  Â  Â  result.innerText = "ğŸ”¥ Red Player Wins!";
Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  result.style.display = "block";
Â  Â  Â  Â  Â  restartBtn.style.display = "block";
Â  Â  Â  Â  Â  menuBtn.style.display = "block";
Â  Â  Â  Â  }

Â  Â  Â  Â  animationId = requestAnimationFrame(gameLoop); // âœ… Store the ID
Â  Â  Â  }

Â  Â  Â  restartBtn.addEventListener("click", () => {
Â  Â  Â  Â  // Reset game state variables
Â  Â  Â  Â  bey1.x = 250; bey1.y = 300; bey1.health = 100; bey1.ultimateCharge = 0;
Â  Â  Â  Â  bey2.x = 350; bey2.y = 300; bey2.health = 100; bey2.ultimateCharge = 0;
Â  Â  Â  Â  bey1.dashActive = bey2.dashActive = false;
Â  Â  Â  Â  bey1.shieldActive = bey2.shieldActive = false;
Â  Â  Â  Â  bey1.ultimateActive = bey2.ultimateActive = false;
Â  Â  Â  Â  // Reset cooldowns
Â  Â  Â  Â  bey1.dashCooldown = bey2.dashCooldown = false;
Â  Â  Â  Â  bey1.shieldCooldown = bey2.shieldCooldown = false;

Â  Â  Â  Â  bey1.isDefeated = bey2.isDefeated = false;
Â  Â  Â  Â  bey1.frame = bey2.frame = 0;

Â  Â  Â  Â  gameOver = false;
Â  Â  Â  Â  gameActive = false; // âœ… Important: Lock movement before countdown

Â  Â  Â  Â  result.style.display = "none"; restartBtn.style.display = "none";
Â  Â  Â  Â  menuBtn.style.display = "none";
Â  Â  Â  Â  startCountdown(() => {
Â  Â  Â  Â  Â  gameActive = true; // âœ… Release movement/physics after countdown
Â  Â  Â  Â  });
Â  Â  Â  Â  // The game loop is already running, so we don't need to call gameLoop() here.
Â  Â  Â  });

Â  Â  Â  function startCountdown(callback) {
Â  Â  Â  Â  let count = 3;
Â  Â  Â  Â  countdownEl.style.display = "block";
Â  Â  Â  Â  countdownEl.innerText = count;
Â  Â  Â  Â  const interval = setInterval(() => {
Â  Â  Â  Â  Â  count--;
Â  Â  Â  Â  Â  if (count > 0) countdownEl.innerText = count;
Â  Â  Â  Â  Â  else if (count === 0) countdownEl.innerText = "GO!";
Â  Â  Â  Â  Â  else {
Â  Â  Â  Â  Â  Â  clearInterval(interval);
Â  Â  Â  Â  Â  Â  countdownEl.style.display = "none";
Â  Â  Â  Â  Â  Â  callback();
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }, 1000);
Â  Â  Â  }

Â  Â  Â  startCountdown(() => {
Â  Â  Â  Â  gameActive = true; // Set active after initial countdown
Â  Â  Â  Â  gameLoop(); // Start the first loop
Â  Â  Â  });
Â  Â  }
Â  </script>
</body>
</html>


